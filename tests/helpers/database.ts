import { config } from 'dotenv';
import type postgres from 'postgres';
import { sql } from 'drizzle-orm';
import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import {
  getGlobalTestDatabase,
  type DatabaseTestSetup,
} from '../../lib/db/test-config';
import { cleanupTestConnections } from '../../lib/db/cleanup';
import * as schema from '../../lib/db/schema';

// Load test environment
config({ path: '.env.test' });

/**
 * Database test helper class for managing test database operations
 */
export class DatabaseTestHelper {
  private static instance: DatabaseTestHelper | null = null;
  private testDb: DatabaseTestSetup | null = null;

  static async getInstance(): Promise<DatabaseTestHelper> {
    if (!DatabaseTestHelper.instance) {
      DatabaseTestHelper.instance = new DatabaseTestHelper();
      await DatabaseTestHelper.instance.initialize();
    }
    return DatabaseTestHelper.instance;
  }

  private async initialize(): Promise<void> {
    this.testDb = await getGlobalTestDatabase();
  }

  /**
   * Get the test database instance
   */
  getDb(): PostgresJsDatabase {
    if (!this.testDb) {
      throw new Error(
        'Test database not initialized. Call getInstance() first.',
      );
    }
    return this.testDb.db;
  }

  /**
   * Get the raw postgres connection
   */
  getConnection(): postgres.Sql {
    if (!this.testDb) {
      throw new Error(
        'Test database not initialized. Call getInstance() first.',
      );
    }
    return this.testDb.connection;
  }

  /**
   * Reset the test database to clean state
   */
  async reset(): Promise<void> {
    if (!this.testDb) {
      throw new Error('Test database not initialized');
    }
    await this.testDb.reset();
  }

  /**
   * Seed the database with fresh test data
   */
  async seed(): Promise<void> {
    if (!this.testDb) {
      throw new Error('Test database not initialized');
    }
    await this.testDb.seed();
  }

  /**
   * Clean up test database connections
   */
  async cleanup(): Promise<void> {
    if (this.testDb) {
      await this.testDb.cleanup();
      this.testDb = null;
    }
    DatabaseTestHelper.instance = null;

    // Use centralized cleanup to ensure all connections are closed
    await cleanupTestConnections();
  }

  /**
   * Create a test user with specific attributes
   */
  async createTestUser(
    overrides: Partial<{
      id: string;
      email: string;
      password: string;
    }> = {},
  ): Promise<schema.User> {
    const db = this.getDb();

    const userData = {
      id: `test-user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      email: `test-${Date.now()}@test.playwright.com`,
      password: 'test-password-hash',
      ...overrides,
    };

    const result = await db.insert(schema.user).values(userData).returning();

    return result[0];
  }

  /**
   * Create a test chat for a user
   */
  async createTestChat(
    userId: string,
    overrides: Partial<{
      id: string;
      title: string;
      visibility: 'public' | 'private';
    }> = {},
  ): Promise<schema.Chat> {
    const db = this.getDb();

    const chatData = {
      id: `test-chat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date(),
      title: `Test Chat ${Date.now()}`,
      userId,
      visibility: 'private' as const,
      ...overrides,
    };

    const result = await db.insert(schema.chat).values(chatData).returning();

    return result[0];
  }

  /**
   * Create a test message in a chat
   */
  async createTestMessage(
    chatId: string,
    overrides: Partial<{
      id: string;
      role: string;
      parts: any[];
      attachments: any[];
    }> = {},
  ): Promise<schema.DBMessage> {
    const db = this.getDb();

    const messageData = {
      id: `test-message-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      chatId,
      role: 'user',
      parts: [{ type: 'text', text: 'Test message content' }],
      attachments: [],
      createdAt: new Date(),
      ...overrides,
    };

    const result = await db
      .insert(schema.message)
      .values(messageData)
      .returning();

    return result[0];
  }

  /**
   * Create test document chunks for RAG testing
   */
  async createTestDocumentChunks(count = 3): Promise<schema.DocumentChunk[]> {
    const db = this.getDb();

    const chunks: Omit<schema.DocumentChunk, 'id'>[] = [];
    const documentId = `test-doc-${Date.now()}`;

    for (let i = 0; i < count; i++) {
      chunks.push({
        content: `Test document chunk ${i + 1}: This contains information about RoboRail operations, safety procedures, and maintenance guidelines.`,
        embedding: null, // Will be generated by embedding system
        documentId,
        filename: `test-document-${i + 1}.pdf`,
        chunkIndex: i + 1,
        metadata: { section: `test-section-${i + 1}`, page: i + 1 },
        createdAt: new Date(),
      });
    }

    const result = await db
      .insert(schema.documentChunk)
      .values(chunks)
      .returning();

    return result;
  }

  /**
   * Clean up test data created by specific test
   */
  async cleanupTestData(patterns: {
    userEmails?: string[];
    chatIds?: string[];
    messageIds?: string[];
    documentIds?: string[];
  }): Promise<void> {
    const db = this.getDb();

    // Clean up in reverse dependency order
    if (patterns.messageIds?.length) {
      await db
        .delete(schema.message)
        .where(sql`id = ANY(${patterns.messageIds})`);
    }

    if (patterns.chatIds?.length) {
      await db.delete(schema.chat).where(sql`id = ANY(${patterns.chatIds})`);
    }

    if (patterns.documentIds?.length) {
      await db
        .delete(schema.documentChunk)
        .where(sql`"documentId" = ANY(${patterns.documentIds})`);
    }

    if (patterns.userEmails?.length) {
      await db
        .delete(schema.user)
        .where(sql`email = ANY(${patterns.userEmails})`);
    }
  }

  /**
   * Get database statistics for test verification
   */
  async getTestStats(): Promise<{
    users: number;
    chats: number;
    messages: number;
    documentChunks: number;
  }> {
    const connection = this.getConnection();

    const stats = await connection`
      SELECT 
        (SELECT COUNT(*) FROM "User") as users,
        (SELECT COUNT(*) FROM "Chat") as chats,
        (SELECT COUNT(*) FROM "Message_v2") as messages,
        (SELECT COUNT(*) FROM "DocumentChunk") as document_chunks;
    `;

    return {
      users: Number(stats[0].users),
      chats: Number(stats[0].chats),
      messages: Number(stats[0].messages),
      documentChunks: Number(stats[0].document_chunks),
    };
  }

  /**
   * Execute raw SQL for advanced test scenarios
   */
  async executeRawSQL(query: string, params: any[] = []): Promise<any[]> {
    const connection = this.getConnection();
    return await connection.unsafe(query, params);
  }

  /**
   * Wait for database operations to complete (useful for async tests)
   */
  async waitForOperations(timeoutMs = 5000): Promise<void> {
    const connection = this.getConnection();
    const timeout = setTimeout(() => {
      throw new Error(`Database operations timeout after ${timeoutMs}ms`);
    }, timeoutMs);

    try {
      await connection`SELECT 1`;
      clearTimeout(timeout);
    } catch (error) {
      clearTimeout(timeout);
      throw error;
    }
  }
}

/**
 * Convenience function to get database helper in tests
 */
export async function getTestDatabase(): Promise<DatabaseTestHelper> {
  return await DatabaseTestHelper.getInstance();
}

/**
 * Setup database for a test suite (call in beforeAll)
 */
export async function setupTestSuite(): Promise<DatabaseTestHelper> {
  const helper = await getTestDatabase();
  await helper.reset();
  await helper.seed();
  return helper;
}

/**
 * Cleanup database after a test suite (call in afterAll)
 */
export async function cleanupTestSuite(): Promise<void> {
  try {
    const helper = await DatabaseTestHelper.getInstance();
    await helper.cleanup();
  } catch (error) {
    console.error('Error during test suite cleanup:', error);
    // Ensure cleanup still happens even if helper fails
    await cleanupTestConnections();
  }
}

/**
 * Reset database between tests (call in beforeEach if needed)
 */
export async function resetBetweenTests(): Promise<void> {
  const helper = await DatabaseTestHelper.getInstance();
  await helper.reset();
  await helper.seed();
}
